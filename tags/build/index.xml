<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>build on Helix&#39;s Blog</title>
    <link>https://helixspiral.github.io/tags/build/</link>
    <description>Recent content in build on Helix&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 27 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://helixspiral.github.io/tags/build/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Environment Configurable vs Environment Agnostic Applications</title>
      <link>https://helixspiral.github.io/posts/2023-09-27-environment-configurable-vs-environment-agnostic-applications/</link>
      <pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://helixspiral.github.io/posts/2023-09-27-environment-configurable-vs-environment-agnostic-applications/</guid>
      <description>Introduction As a member of an operations team you want things to be easy, you want things to &amp;ldquo;just work&amp;rdquo; the same way in a testing environment as they do in a production one. In this post we&amp;rsquo;ll cover applications that need to be configured, and how to remove those needed configurations in favor of an application that &amp;ldquo;just works&amp;rdquo;.
Environment configurable Here is our example environment configurable application:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; &amp;#34;github.</description>
    </item>
    
    <item>
      <title>Multi-arch Docker builds with Rust</title>
      <link>https://helixspiral.github.io/posts/2023-06-16-rust-multiarch-docker/</link>
      <pubDate>Fri, 16 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://helixspiral.github.io/posts/2023-06-16-rust-multiarch-docker/</guid>
      <description>Introduction I&amp;rsquo;ve recently been playing with some Rust projects, and one of the biggest struggles I had was getting a small platform agnostic Docker image that I could use to build any platform using docker buildx.
The code I wrote a very small program that spits out a random number along with the current architecture to use as an sample for our Docker work.
use rand::Rng; use current_platform::CURRENT_PLATFORM; fn main() { let mut rng = rand::thread_rng(); let r_num: u8 = rng.</description>
    </item>
    
    <item>
      <title>Ensuring backwards compatibility in deployments by leveraging git tags</title>
      <link>https://helixspiral.github.io/posts/2021-04-02-using-git-tags-to-ensure-deployment-backwards-compability/</link>
      <pubDate>Fri, 02 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://helixspiral.github.io/posts/2021-04-02-using-git-tags-to-ensure-deployment-backwards-compability/</guid>
      <description>Overview I recently came across a blog post on injecting variables into Golang at build time and that gave me the idea for this blog post. Automating versioning and ensuring backwards compatibility.
GitHub repository and sample application You can find the code for this application here, on my GitHub
Git tags and versioning This blog post assumes some basic understanding of the git version control system. For anyone new to it you can probably get by with thinking that commits are incremental changes to the software and tags are user-created labels that reference a specific commit.</description>
    </item>
    
  </channel>
</rss>
